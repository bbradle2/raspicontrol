   
   const int NUM_PRINTERS = 3; // Number of available printers
std::counting_semaphore<NUM_PRINTERS> printer_semaphore(NUM_PRINTERS);

void print_document(int computer_id)
{
    std::osyncstream synced_out(std::cout);
    synced_out << "Computer " << computer_id << " is trying to acquire a printer." << std::endl;
    printer_semaphore.acquire(); // Acquire a printer (decrement semaphore count)
    synced_out << "Computer " << computer_id << " acquired a printer and is printing..." << std::endl;
    std::this_thread::sleep_for(std::chrono::seconds(2)); // Simulate printing time
    synced_out << "Computer " << computer_id << " finished printing and is releasing the printer." << std::endl;
    printer_semaphore.release(); // Release the printer (increment semaphore count)
}


std::vector<std::thread> computers;
        for (int i = 1; i <= 5; ++i)
        { // 5 computers trying to print
            computers.emplace_back(print_document, i);
        }

        for (auto &t : computers)
        {
            //t.request_stop();

            //if(t.joinable())
                t.join();
        }

        std::cout << "All printing tasks completed." << std::endl;
   
    // while (true)
    // {
    //     if(_line.event_wait(std::chrono::milliseconds(10)))
    //     {
    //         auto line_event = _line.event_read();
    //         if(line_event.event_type == line_event.RISING_EDGE)
    //         {
    //             std::cout << "Rising edge detected on GPIO " << line_event.source.name() << std::endl;
    //         }
    //         else if (line_event.event_type == line_event.FALLING_EDGE)
    //         {
    //             std::cout << "Falling edge detected on GPIO " << line_event.source.name() << std::endl;
    //         }
    //     }

    //     // Small delay to prevent busy-waiting
    // }
struct Person
{
    std::string name;
    std::string address;
    int age;
};

#include "Poco/Data/MySQL/Connector.h" //MySQL
#include "Poco/Data/SQLite/Connector.h" //SQLite
#include "Poco/Data/PostgreSQL/Connector.h" //PostgreSQL


//For MySQL and SQLite thru POCO libraries
//There differences in sql statements between MySQL and SQLite what Connector and Session to use
Poco::Data::MySQL::Connector::registerConnector(); //MySQL
Poco::Data::SQLite::Connector::registerConnector(); //SQLite
Poco::Data::PostgreSQL::Connector::registerConnector(); //PostgreSQL



        // create a session
        Session session("MySQL", "host=192.168.7.136;port=3306;db=bbb;user=user;password=password;compress=true;auto-reconnect=true"); //MySQL
        Session session("SQLite", "example.db"); //SQLite
        Session session("PostgreSQL", "host=192.168.7.136 port=5432 user=postgres dbname=postgres"); //PostgreSQL

        session << "DROP TABLE IF EXISTS Person", now;

        // (re)create table
        session << "CREATE TABLE Person (Name VARCHAR(30), Address VARCHAR(50), Age INT)", now;

        Person person =
            {
                "Bart Simpson",
                "Springfield",
                12};
        Statement insert(session);
        insert << "INSERT INTO Person (name, address, age) VALUES($1, $2, $3)",
            use(person.name),
            use(person.address),
            use(person.age); 
        insert.execute();
        insert.reset(session);

        person.name = "Lisa Simpson";
        person.address = "Springfield";
        person.age = 10;
        insert << "INSERT INTO Person (name, address, age) VALUES($1, $2, $3)",
            use(person.name),
            use(person.address),
            use(person.age); 
        insert.execute();

        Statement select(session);
        select << "SELECT Name, Address, Age FROM Person",
            into(person.name),
            into(person.address),
            into(person.age),
            range(0, 1); //  iterate over result set one row at a time

        while (!select.done())
        {
            select.execute();
            std::cout << person.name << " " << person.address << " " << person.age << std::endl;
        }
Poco::Data::MySQL::Connector::unregisterConnector();
Poco::Data::SQLite::Connector::unregisterConnector();
Poco::Data::PostgreSQL::Connector::unregisterConnector();



// static void commandThreadFunction(); //header
// void utilFuncs::commandThreadFunction()
// {
//     std::cout << "begin utilfuncs::commandThreadFunction: " << getDateTimeLocal() << std::endl;
//     std::string command;

//     while (std::cin >> command)
//     {
//         if (command == "quit")
//         {
//             shutdownFlag.store(true);
//             break;
//         }

//         std::cin.clear();
//     }

//     std::cout << "end utilfuncs::commandThreadFunction: " << getDateTimeLocal() << std::endl;
// }
//For sqlite
static int sqlCallback(void *data, int argc, char **argv, char **azColName); //header
int utilFuncs::sqlCallback(void *data, int argc, char **argv, char **azColName)
{
    (void)data;
    int i;
    // fprintf(stderr, "%s: ", (const char *)data);

    for (i = 0; i < argc; i++)
    {
        printf("%s = %s\n", azColName[i], argv[i] ? argv[i] : "NULL");
    }

    //printf("\n");
    return 0;
}

 MySql client
 sql::Driver *driver;
        sql::Connection *con;
        sql::Statement *stmt;
        sql::ResultSet *res;
        driver = get_driver_instance();

        con = driver->connect("tcp://192.168.7.136:3306", "bbrad", "fred5858");

        con->setSchema("bbb");

        stmt = con->createStatement();
        res = stmt->executeQuery("SELECT * FROM customer");

        while (res->next())
        {
            cout << "custname: " << res->getString("custname") << endl; // Or res->getString(1)
        }

        // Clean up
        delete res;
        delete stmt;
        delete con;

class SSLInitializer
{
 	  public:
 		SSLInitializer() { initializeSSL(); }

 		~SSLInitializer() { uninitializeSSL(); }
};
 // SSLInitializer sslInitializer;

        // SSLManager::InvalidCertificateHandlerPtr ptrHandler(new AcceptCertificateHandler(false));
        // Context::Ptr ptrContext = new Context(Context::TLS_CLIENT_USE, "");
        // SSLManager::instance().initializeClient(0, ptrHandler, ptrContext);

        // URI uri("https://www.google.com/");
        // HTTPSClientSession s(uri.getHost(), uri.getPort(), ptrContext);

        // HTTPRequest request = HTTPRequest(HTTPRequest::HTTP_GET, uri.getPath(), HTTPMessage::HTTP_1_1);
        // s.sendRequest(request);
        // HTTPResponse response;
        // auto &is = s.receiveResponse(response);
        // StreamCopier::copyStream(is, std::cout);

        // string key;
        // string value;
        // NameValueCollection::ConstIterator ii = response.begin();

        // while (ii != response.end())
        // {
        // key = ii->first;
        // value = ii->second;
        // cout << key << "------" << value << endl
        //         << flush;
        // ++ii;
        // }

        // static constexpr size_t AES_KEY_SIZE = 256 / 8; // AES-256

        // const std::string input{"This is a secret message."};
        // std::vector<uint8_t> key(AES_KEY_SIZE);
        // std::vector<uint8_t> iv(CryptoPP::AES::BLOCKSIZE);

        // CryptoPP::BlockingRng rand;
        // rand.GenerateBlock(key.data(), key.size());
        // rand.GenerateBlock(iv.data(), iv.size());

        // auto cipher = utilFuncs::encrypt(input, key, iv);
        // auto plain_text = utilFuncs::decrypt(cipher, key, iv);

        // if (plain_text != input)
        // {
        //     std::cout << "Error: plain text doesn't match the input" << std::endl;
        // }
        // else
        // {
        //     std::cout << "input : " << input << std::endl;
        //     std::cout << "cipher : " << cipher;
        //     std::cout << "plain text : " << plain_text << std::endl;
        // }

        // std::cout << std::endl;
        // char *messaggeError;
        // int exit = 0;
        // sqlite3 *DB;
        // exit = sqlite3_open("example.db", &DB);

        // std::string dropTableSql = "DROP TABLE PERSON;";
        // exit = sqlite3_exec(DB, dropTableSql.c_str(), NULL, 0, &messaggeError);
        // if (exit != SQLITE_OK)
        // {
        //     std::cerr << "DROP TABLE PERSON" << std::endl;
        //     sqlite3_free(messaggeError);
        // }
        // else
        // {
        //     std::cout << "DROP TABLE PERSON Success!" << std::endl;
        // }

        // std::string createTableSql = "CREATE TABLE PERSON("
        //                             "ID INT PRIMARY KEY     NOT NULL, "
        //                             "NAME           TEXT    NOT NULL, "
        //                             "SURNAME          TEXT     NOT NULL, "
        //                             "AGE            INT     NOT NULL, "
        //                             "ADDRESS        CHAR(50), "
        //                             "SALARY         REAL );";

        // exit = sqlite3_exec(DB, createTableSql.c_str(), NULL, 0, &messaggeError);

        // if (exit != SQLITE_OK)
        // {
        //     std::cerr << "CREATE TABLE PERSON Error!" << std::endl;
        //     sqlite3_free(messaggeError);
        // }
        // else
        // {
        //     std::cout << "CREATE TABLE PERSON Success!" << std::endl;
        // }

         // std::string insertSql("INSERT INTO PERSON VALUES(1, 'STEVE', 'GATES', 30, 'PALO ALTO', 1000.0);"
         //                       "INSERT INTO PERSON VALUES(2, 'BILL', 'ALLEN', 20, 'SEATTLE', 300.22);"
         //                       "INSERT INTO PERSON VALUES(3, 'PAUL', 'JOBS', 24, 'SEATTLE', 9900.0);");

         // exit = sqlite3_exec(DB, insertSql.c_str(), NULL, 0, &messaggeError);
         // if (exit != SQLITE_OK)
         // {
         //     std::cerr << "INSERT INTO PERSON Error!" << std::endl;
         //     sqlite3_free(messaggeError);
         // }
         // else
         // {
         //     std::cout << "INSERT INTO PERSON Success!" << std::endl
         //               << std::endl;
         // }

         // std::string selectSql = "SELECT NAME FROM PERSON;";
         // std::cout << "SELECT NAME FROM PERSON Starting!" << std::endl;
         // exit = sqlite3_exec(DB, selectSql.c_str(), utilFuncs::sqlCallback, NULL, NULL);

         // if (exit != SQLITE_OK)
         // {
         //     std::cerr << "SELECT NAME FROM PERSON Error!" << std::endl;
         //     sqlite3_free(messaggeError);
         // }
         // else
         // {
         //     std::cout << "SELECT NAME FROM PERSON Success!" << std::endl
         //               << std::endl;
         // }
        // sqlite3_close(DB);

         // goto exxit;
         //  uuid_t uuid;
         //  char cuuid[37] = {};

         // uuid_generate_random(uuid);
         // uuid_unparse_upper(uuid, cuuid);

         // std::cout << cuuid << std::endl;

         // goto exit;

         // shutdownFlag.store(false);
         // static std::jthread shutdownThread = std::jthread(utilfuncs::commandThreadFunction);

        //   Defer d = defer(
        //                   []()
        //                   {
        //                       //shutdownThread.request_stop();
        //                       //shutdownThread.join();
        //                       line.set_value(0);
        //                       line.release();
        //                       std::cout << "Program Stopped: " <<  utilFuncs::getDateTimeLocal() << std::endl;
        //                   });

          //gpiod::chip chip("gpiochip0");
          //chip.open("gpiochip0");
          //auto line = chip.get_line(23); // GPIO 23
          //line.request({"led-toggle",
          //              gpiod::line_request::DIRECTION_OUTPUT});

          // while (shutdownFlag.load() == false)
          //{
          //line.set_value(0);
          //std::this_thread::sleep_for(1000ms);
          //line.set_value(1);
          //std::this_thread::sleep_for(1000ms);
         // //}




class SpinLock
{
    std::atomic_flag flag = ATOMIC_FLAG_INIT;

public:
    void lock()
    {
        // Loop until we successfully set the flag from false â†’ true
        while (flag.test_and_set(std::memory_order_acquire))
        {
            std::atomic_signal_fence(std::memory_order_seq_cst);
        }
    }

    void unlock()
    {
        flag.clear(std::memory_order_release);
    }
};

struct spinlock {
  std::atomic<bool> lock_ = {0};

  void lock() noexcept {
    for (;;) {
      // Optimistically assume the lock is free on the first try
      if (!lock_.exchange(true, std::memory_order_acquire)) {
        return;
      }
      // Wait for lock to be released without generating cache misses
      while (lock_.load(std::memory_order_relaxed)) {
        // Issue X86 PAUSE or ARM YIELD instruction to reduce contention between
        // hyper-threads
        __builtin_ia32_pause();
      }
    }
  }

  bool try_lock() noexcept {
    // First do a relaxed load to check if lock is free in order to prevent
    // unnecessary cache misses if someone does while(!try_lock())
    return !lock_.load(std::memory_order_relaxed) &&
           !lock_.exchange(true, std::memory_order_acquire);
  }

  void unlock() noexcept {
    lock_.store(false, std::memory_order_release);
  }
};



/* memory mapping file */
int handle_error(const std::error_code &error);
void allocate_file(const std::string &path, const int size);

int main(int argc, char **argv)
{
    try
    {
        const auto path = "file.txt";

        // NOTE: mio does *not* create the file for you if it doesn't exist! You
        // must ensure that the file exists before establishing a mapping. It
        // must also be non-empty. So for illustrative purposes the file is
        // created now.
        allocate_file(path, 155);

        // Read-write memory map the whole file by using `map_entire_file` where the
        // length of the mapping is otherwise expected, with the factory method.
        std::error_code error;
        mio::mmap_sink rw_mmap = mio::make_mmap_sink(
            path, 0, mio::map_entire_file, error);
        if (error)
        {
            return handle_error(error);
        }

        // You can use any iterator based function.
        std::fill(rw_mmap.begin(), rw_mmap.end(), 'a');

        // Or manually iterate through the mapped region just as if it were any other
        // container, and change each byte's value (since this is a read-write mapping).
        for (auto &b : rw_mmap)
        {
            b += 10;
        }

        // Or just change one value with the subscript operator.
        const int answer_index = rw_mmap.size() / 2;
        rw_mmap[answer_index] = 42;

        // Don't forget to flush changes to disk before unmapping. However, if
        // `rw_mmap` were to go out of scope at this point, the destructor would also
        // automatically invoke `sync` before `unmap`.
        rw_mmap.sync(error);
        if (error)
        {
            return handle_error(error);
        }

        // We can then remove the mapping, after which rw_mmap will be in a default
        // constructed state, i.e. this and the above call to `sync` have the same
        // effect as if the destructor had been invoked.
        rw_mmap.unmap();

        // Now create the same mapping, but in read-only mode. Note that calling the
        // overload without the offset and file length parameters maps the entire
        // file.
        mio::mmap_source ro_mmap;
        ro_mmap.map(path, error);
        if (error)
        {
            return handle_error(error);
        }

        const int the_answer_to_everything = ro_mmap[answer_index];
        assert(the_answer_to_everything == 42);

        std::cout << "Program Started: " << utilFuncs::getDateTimeLocal() << std::endl;
        std::cout << "Build Date: " << __DATE__ << std::endl;
        std::cout << "Build Time: " << __TIME__ << std::endl;

        std::cout << std::endl;
        std::cout << "argc: " << argc << std::endl;
        for (int i = 0; i < argc; i++)
        {
            std::cout << "argv[" << i << "]: " << argv[i] << std::endl;
        }
       
        // gpioController gpioCtl;

        // gpioCtl.getGpios()[RaspberryPiDefines::GPIO23]->setGpioValue(1);
        // gpioCtl.getGpios()[RaspberryPiDefines::GPIO24]->setGpioValue(1);
        // std::this_thread::sleep_for(1000ms);
        // gpioCtl.getGpios()[RaspberryPiDefines::GPIO23]->setGpioValue(0);
        // gpioCtl.getGpios()[RaspberryPiDefines::GPIO24]->setGpioValue(0);
    }
    catch (const Poco::Exception &e)
    {
        std::cerr << "Error: " << e.displayText() << " " << utilFuncs::getDateTimeLocal() << std::endl;
    }
    catch (boost::exception &e)
    {
        std::cerr << "Error: " << boost::diagnostic_information(e) << std::endl;
    }
    catch (const exception &e)
    {
        std::cerr << "Error: " << e.what() << " " << utilFuncs::getDateTimeLocal() << std::endl;
    }

    std::cout << "Program Stopped: " << utilFuncs::getDateTimeLocal() << std::endl;
    return 0;
}

int handle_error(const std::error_code &error)
{
    const auto &errmsg = error.message();
    std::printf("error mapping file: %s, exiting...\n", errmsg.c_str());
    return error.value();
}

void allocate_file(const std::string &path, const int size)
{
    std::ofstream file(path);
    std::string s(size, '0');
    file << s;
}


        //gpioController gpioCtl;
        // std::cout << "Gpio 23 Value:" << gpioCtl.getGpios()[GPIO23]->setGpioValue(1) << std::endl;
        // std::this_thread::sleep_for(1000ms); // delay for 1000 milliseconds.
        // std::cout << "Gpio 23 Value:" << gpioCtl.getGpios()[GPIO23]->setGpioValue(0) << std::endl;


        httplib::Server svr;
       

        svr.Get("/hi", [](const httplib::Request &req, httplib::Response &res)
                 { 
                     res.set_content("Hello World!", "text/plain"); 
                 });

        svr.listen("0.0.0.0", 8080);


        gpioController gpioCtl;
        std::cout << "Gpio 23 Value:" << gpioCtl.getGpios()[GPIO23]->setGpioValue(1) << std::endl;
        std::this_thread::sleep_for(1000ms); // delay for 1000 milliseconds.
        std::cout << "Gpio 23 Value:" << gpioCtl.getGpios()[GPIO23]->setGpioValue(0) << std::endl;


int find_the_answer()
{
    std::this_thread::sleep_for(std::chrono::seconds(2)); // Simulate work
    return 42;
}
        
        std::future<int> future = std::async(std::launch::async, find_the_answer);

        std::cout << "Doing other things while waiting for the answer..." << std::endl;

        // Wait for the result and retrieve it
        int answer = future.get(); // Blocks until the result is ready

        std::cout << "The answer is: " << answer << std::endl;
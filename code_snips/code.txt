   
   const int NUM_PRINTERS = 3; // Number of available printers
std::counting_semaphore<NUM_PRINTERS> printer_semaphore(NUM_PRINTERS);

void print_document(int computer_id)
{
    std::osyncstream synced_out(std::cout);
    synced_out << "Computer " << computer_id << " is trying to acquire a printer." << std::endl;
    printer_semaphore.acquire(); // Acquire a printer (decrement semaphore count)
    synced_out << "Computer " << computer_id << " acquired a printer and is printing..." << std::endl;
    std::this_thread::sleep_for(std::chrono::seconds(2)); // Simulate printing time
    synced_out << "Computer " << computer_id << " finished printing and is releasing the printer." << std::endl;
    printer_semaphore.release(); // Release the printer (increment semaphore count)
}


std::vector<std::thread> computers;
        for (int i = 1; i <= 5; ++i)
        { // 5 computers trying to print
            computers.emplace_back(print_document, i);
        }

        for (auto &t : computers)
        {
            //t.request_stop();

            //if(t.joinable())
                t.join();
        }

        std::cout << "All printing tasks completed." << std::endl;
   
    // while (true)
    // {
    //     if(_line.event_wait(std::chrono::milliseconds(10)))
    //     {
    //         auto line_event = _line.event_read();
    //         if(line_event.event_type == line_event.RISING_EDGE)
    //         {
    //             std::cout << "Rising edge detected on GPIO " << line_event.source.name() << std::endl;
    //         }
    //         else if (line_event.event_type == line_event.FALLING_EDGE)
    //         {
    //             std::cout << "Falling edge detected on GPIO " << line_event.source.name() << std::endl;
    //         }
    //     }

    //     // Small delay to prevent busy-waiting
    // }
struct Person
{
    std::string name;
    std::string address;
    int age;
};

#include "Poco/Data/MySQL/Connector.h" //MySQL
#include "Poco/Data/SQLite/Connector.h" //SQLite
#include "Poco/Data/PostgreSQL/Connector.h" //PostgreSQL


//For MySQL and SQLite thru POCO libraries
//There differences in sql statements between MySQL and SQLite what Connector and Session to use
Poco::Data::MySQL::Connector::registerConnector(); //MySQL
Poco::Data::SQLite::Connector::registerConnector(); //SQLite
Poco::Data::PostgreSQL::Connector::registerConnector(); //PostgreSQL



        // create a session
        Session session("MySQL", "host=192.168.7.136;port=3306;db=bbb;user=user;password=password;compress=true;auto-reconnect=true"); //MySQL
        Session session("SQLite", "example.db"); //SQLite
        Session session("PostgreSQL", "host=192.168.7.136 port=5432 user=postgres dbname=postgres"); //PostgreSQL

        session << "DROP TABLE IF EXISTS Person", now;

        // (re)create table
        session << "CREATE TABLE Person (Name VARCHAR(30), Address VARCHAR(50), Age INT)", now;

        Person person =
            {
                "Bart Simpson",
                "Springfield",
                12};
        Statement insert(session);
        insert << "INSERT INTO Person (name, address, age) VALUES($1, $2, $3)",
            use(person.name),
            use(person.address),
            use(person.age); 
        insert.execute();
        insert.reset(session);

        person.name = "Lisa Simpson";
        person.address = "Springfield";
        person.age = 10;
        insert << "INSERT INTO Person (name, address, age) VALUES($1, $2, $3)",
            use(person.name),
            use(person.address),
            use(person.age); 
        insert.execute();

        Statement select(session);
        select << "SELECT Name, Address, Age FROM Person",
            into(person.name),
            into(person.address),
            into(person.age),
            range(0, 1); //  iterate over result set one row at a time

        while (!select.done())
        {
            select.execute();
            std::cout << person.name << " " << person.address << " " << person.age << std::endl;
        }
Poco::Data::MySQL::Connector::unregisterConnector();
Poco::Data::SQLite::Connector::unregisterConnector();
Poco::Data::PostgreSQL::Connector::unregisterConnector();



// static void commandThreadFunction(); //header
// void utilFuncs::commandThreadFunction()
// {
//     std::cout << "begin utilfuncs::commandThreadFunction: " << getDateTimeLocal() << std::endl;
//     std::string command;

//     while (std::cin >> command)
//     {
//         if (command == "quit")
//         {
//             shutdownFlag.store(true);
//             break;
//         }

//         std::cin.clear();
//     }

//     std::cout << "end utilfuncs::commandThreadFunction: " << getDateTimeLocal() << std::endl;
// }
//For sqlite
static int sqlCallback(void *data, int argc, char **argv, char **azColName); //header
int utilFuncs::sqlCallback(void *data, int argc, char **argv, char **azColName)
{
    (void)data;
    int i;
    // fprintf(stderr, "%s: ", (const char *)data);

    for (i = 0; i < argc; i++)
    {
        printf("%s = %s\n", azColName[i], argv[i] ? argv[i] : "NULL");
    }

    //printf("\n");
    return 0;
}

 MySql client
 sql::Driver *driver;
        sql::Connection *con;
        sql::Statement *stmt;
        sql::ResultSet *res;
        driver = get_driver_instance();

        con = driver->connect("tcp://192.168.7.136:3306", "bbrad", "fred5858");

        con->setSchema("bbb");

        stmt = con->createStatement();
        res = stmt->executeQuery("SELECT * FROM customer");

        while (res->next())
        {
            cout << "custname: " << res->getString("custname") << endl; // Or res->getString(1)
        }

        // Clean up
        delete res;
        delete stmt;
        delete con;

class SSLInitializer
{
 	  public:
 		SSLInitializer() { initializeSSL(); }

 		~SSLInitializer() { uninitializeSSL(); }
};
 // SSLInitializer sslInitializer;

        // SSLManager::InvalidCertificateHandlerPtr ptrHandler(new AcceptCertificateHandler(false));
        // Context::Ptr ptrContext = new Context(Context::TLS_CLIENT_USE, "");
        // SSLManager::instance().initializeClient(0, ptrHandler, ptrContext);

        // URI uri("https://www.google.com/");
        // HTTPSClientSession s(uri.getHost(), uri.getPort(), ptrContext);

        // HTTPRequest request = HTTPRequest(HTTPRequest::HTTP_GET, uri.getPath(), HTTPMessage::HTTP_1_1);
        // s.sendRequest(request);
        // HTTPResponse response;
        // auto &is = s.receiveResponse(response);
        // StreamCopier::copyStream(is, std::cout);

        // string key;
        // string value;
        // NameValueCollection::ConstIterator ii = response.begin();

        // while (ii != response.end())
        // {
        // key = ii->first;
        // value = ii->second;
        // cout << key << "------" << value << endl
        //         << flush;
        // ++ii;
        // }

        // static constexpr size_t AES_KEY_SIZE = 256 / 8; // AES-256

        // const std::string input{"This is a secret message."};
        // std::vector<uint8_t> key(AES_KEY_SIZE);
        // std::vector<uint8_t> iv(CryptoPP::AES::BLOCKSIZE);

        // CryptoPP::BlockingRng rand;
        // rand.GenerateBlock(key.data(), key.size());
        // rand.GenerateBlock(iv.data(), iv.size());

        // auto cipher = utilFuncs::encrypt(input, key, iv);
        // auto plain_text = utilFuncs::decrypt(cipher, key, iv);

        // if (plain_text != input)
        // {
        //     std::cout << "Error: plain text doesn't match the input" << std::endl;
        // }
        // else
        // {
        //     std::cout << "input : " << input << std::endl;
        //     std::cout << "cipher : " << cipher;
        //     std::cout << "plain text : " << plain_text << std::endl;
        // }

        // std::cout << std::endl;
        // char *messaggeError;
        // int exit = 0;
        // sqlite3 *DB;
        // exit = sqlite3_open("example.db", &DB);

        // std::string dropTableSql = "DROP TABLE PERSON;";
        // exit = sqlite3_exec(DB, dropTableSql.c_str(), NULL, 0, &messaggeError);
        // if (exit != SQLITE_OK)
        // {
        //     std::cerr << "DROP TABLE PERSON" << std::endl;
        //     sqlite3_free(messaggeError);
        // }
        // else
        // {
        //     std::cout << "DROP TABLE PERSON Success!" << std::endl;
        // }

        // std::string createTableSql = "CREATE TABLE PERSON("
        //                             "ID INT PRIMARY KEY     NOT NULL, "
        //                             "NAME           TEXT    NOT NULL, "
        //                             "SURNAME          TEXT     NOT NULL, "
        //                             "AGE            INT     NOT NULL, "
        //                             "ADDRESS        CHAR(50), "
        //                             "SALARY         REAL );";

        // exit = sqlite3_exec(DB, createTableSql.c_str(), NULL, 0, &messaggeError);

        // if (exit != SQLITE_OK)
        // {
        //     std::cerr << "CREATE TABLE PERSON Error!" << std::endl;
        //     sqlite3_free(messaggeError);
        // }
        // else
        // {
        //     std::cout << "CREATE TABLE PERSON Success!" << std::endl;
        // }

         // std::string insertSql("INSERT INTO PERSON VALUES(1, 'STEVE', 'GATES', 30, 'PALO ALTO', 1000.0);"
         //                       "INSERT INTO PERSON VALUES(2, 'BILL', 'ALLEN', 20, 'SEATTLE', 300.22);"
         //                       "INSERT INTO PERSON VALUES(3, 'PAUL', 'JOBS', 24, 'SEATTLE', 9900.0);");

         // exit = sqlite3_exec(DB, insertSql.c_str(), NULL, 0, &messaggeError);
         // if (exit != SQLITE_OK)
         // {
         //     std::cerr << "INSERT INTO PERSON Error!" << std::endl;
         //     sqlite3_free(messaggeError);
         // }
         // else
         // {
         //     std::cout << "INSERT INTO PERSON Success!" << std::endl
         //               << std::endl;
         // }

         // std::string selectSql = "SELECT NAME FROM PERSON;";
         // std::cout << "SELECT NAME FROM PERSON Starting!" << std::endl;
         // exit = sqlite3_exec(DB, selectSql.c_str(), utilFuncs::sqlCallback, NULL, NULL);

         // if (exit != SQLITE_OK)
         // {
         //     std::cerr << "SELECT NAME FROM PERSON Error!" << std::endl;
         //     sqlite3_free(messaggeError);
         // }
         // else
         // {
         //     std::cout << "SELECT NAME FROM PERSON Success!" << std::endl
         //               << std::endl;
         // }
        // sqlite3_close(DB);

         // goto exxit;
         //  uuid_t uuid;
         //  char cuuid[37] = {};

         // uuid_generate_random(uuid);
         // uuid_unparse_upper(uuid, cuuid);

         // std::cout << cuuid << std::endl;

         // goto exit;

         // shutdownFlag.store(false);
         // static std::jthread shutdownThread = std::jthread(utilfuncs::commandThreadFunction);

        //   Defer d = defer(
        //                   []()
        //                   {
        //                       //shutdownThread.request_stop();
        //                       //shutdownThread.join();
        //                       line.set_value(0);
        //                       line.release();
        //                       std::cout << "Program Stopped: " <<  utilFuncs::getDateTimeLocal() << std::endl;
        //                   });

          //gpiod::chip chip("gpiochip0");
          //chip.open("gpiochip0");
          //auto line = chip.get_line(23); // GPIO 23
          //line.request({"led-toggle",
          //              gpiod::line_request::DIRECTION_OUTPUT});

          // while (shutdownFlag.load() == false)
          //{
          //line.set_value(0);
          //std::this_thread::sleep_for(1000ms);
          //line.set_value(1);
          //std::this_thread::sleep_for(1000ms);
         // //}




class SpinLock
{
    std::atomic_flag flag = ATOMIC_FLAG_INIT;

public:
    void lock()
    {
        // Loop until we successfully set the flag from false â†’ true
        while (flag.test_and_set(std::memory_order_acquire))
        {
            std::atomic_signal_fence(std::memory_order_seq_cst);
        }
    }

    void unlock()
    {
        flag.clear(std::memory_order_release);
    }
};

struct spinlock {
  std::atomic<bool> lock_ = {0};

  void lock() noexcept {
    for (;;) {
      // Optimistically assume the lock is free on the first try
      if (!lock_.exchange(true, std::memory_order_acquire)) {
        return;
      }
      // Wait for lock to be released without generating cache misses
      while (lock_.load(std::memory_order_relaxed)) {
        // Issue X86 PAUSE or ARM YIELD instruction to reduce contention between
        // hyper-threads
        __builtin_ia32_pause();
      }
    }
  }

  bool try_lock() noexcept {
    // First do a relaxed load to check if lock is free in order to prevent
    // unnecessary cache misses if someone does while(!try_lock())
    return !lock_.load(std::memory_order_relaxed) &&
           !lock_.exchange(true, std::memory_order_acquire);
  }

  void unlock() noexcept {
    lock_.store(false, std::memory_order_release);
  }
};



/* memory mapping file */
int handle_error(const std::error_code &error);
void allocate_file(const std::string &path, const int size);

int main(int argc, char **argv)
{
    try
    {
        const auto path = "file.txt";

        // NOTE: mio does *not* create the file for you if it doesn't exist! You
        // must ensure that the file exists before establishing a mapping. It
        // must also be non-empty. So for illustrative purposes the file is
        // created now.
        allocate_file(path, 155);

        // Read-write memory map the whole file by using `map_entire_file` where the
        // length of the mapping is otherwise expected, with the factory method.
        std::error_code error;
        mio::mmap_sink rw_mmap = mio::make_mmap_sink(
            path, 0, mio::map_entire_file, error);
        if (error)
        {
            return handle_error(error);
        }

        // You can use any iterator based function.
        std::fill(rw_mmap.begin(), rw_mmap.end(), 'a');

        // Or manually iterate through the mapped region just as if it were any other
        // container, and change each byte's value (since this is a read-write mapping).
        for (auto &b : rw_mmap)
        {
            b += 10;
        }

        // Or just change one value with the subscript operator.
        const int answer_index = rw_mmap.size() / 2;
        rw_mmap[answer_index] = 42;

        // Don't forget to flush changes to disk before unmapping. However, if
        // `rw_mmap` were to go out of scope at this point, the destructor would also
        // automatically invoke `sync` before `unmap`.
        rw_mmap.sync(error);
        if (error)
        {
            return handle_error(error);
        }

        // We can then remove the mapping, after which rw_mmap will be in a default
        // constructed state, i.e. this and the above call to `sync` have the same
        // effect as if the destructor had been invoked.
        rw_mmap.unmap();

        // Now create the same mapping, but in read-only mode. Note that calling the
        // overload without the offset and file length parameters maps the entire
        // file.
        mio::mmap_source ro_mmap;
        ro_mmap.map(path, error);
        if (error)
        {
            return handle_error(error);
        }

        const int the_answer_to_everything = ro_mmap[answer_index];
        assert(the_answer_to_everything == 42);

        std::cout << "Program Started: " << utilFuncs::getDateTimeLocal() << std::endl;
        std::cout << "Build Date: " << __DATE__ << std::endl;
        std::cout << "Build Time: " << __TIME__ << std::endl;

        std::cout << std::endl;
        std::cout << "argc: " << argc << std::endl;
        for (int i = 0; i < argc; i++)
        {
            std::cout << "argv[" << i << "]: " << argv[i] << std::endl;
        }
       
        // gpioController gpioCtl;

        // gpioCtl.getGpios()[RaspberryPiDefines::GPIO23]->setGpioValue(1);
        // gpioCtl.getGpios()[RaspberryPiDefines::GPIO24]->setGpioValue(1);
        // std::this_thread::sleep_for(1000ms);
        // gpioCtl.getGpios()[RaspberryPiDefines::GPIO23]->setGpioValue(0);
        // gpioCtl.getGpios()[RaspberryPiDefines::GPIO24]->setGpioValue(0);
    }
    catch (const Poco::Exception &e)
    {
        std::cerr << "Error: " << e.displayText() << " " << utilFuncs::getDateTimeLocal() << std::endl;
    }
    catch (boost::exception &e)
    {
        std::cerr << "Error: " << boost::diagnostic_information(e) << std::endl;
    }
    catch (const exception &e)
    {
        std::cerr << "Error: " << e.what() << " " << utilFuncs::getDateTimeLocal() << std::endl;
    }

    std::cout << "Program Stopped: " << utilFuncs::getDateTimeLocal() << std::endl;
    return 0;
}

int handle_error(const std::error_code &error)
{
    const auto &errmsg = error.message();
    std::printf("error mapping file: %s, exiting...\n", errmsg.c_str());
    return error.value();
}

void allocate_file(const std::string &path, const int size)
{
    std::ofstream file(path);
    std::string s(size, '0');
    file << s;
}


        //gpioController gpioCtl;
        // std::cout << "Gpio 23 Value:" << gpioCtl.getGpios()[GPIO23]->setGpioValue(1) << std::endl;
        // std::this_thread::sleep_for(1000ms); // delay for 1000 milliseconds.
        // std::cout << "Gpio 23 Value:" << gpioCtl.getGpios()[GPIO23]->setGpioValue(0) << std::endl;


        httplib::Server svr;
       

        svr.Get("/hi", [](const httplib::Request &req, httplib::Response &res)
                 { 
                     res.set_content("Hello World!", "text/plain"); 
                 });

        svr.listen("0.0.0.0", 8080);


        gpioController gpioCtl;
        std::cout << "Gpio 23 Value:" << gpioCtl.getGpios()[GPIO23]->setGpioValue(1) << std::endl;
        std::this_thread::sleep_for(1000ms); // delay for 1000 milliseconds.
        std::cout << "Gpio 23 Value:" << gpioCtl.getGpios()[GPIO23]->setGpioValue(0) << std::endl;


int find_the_answer()
{
    std::this_thread::sleep_for(std::chrono::seconds(2)); // Simulate work
    return 42;
}
        
        std::future<int> future = std::async(std::launch::async, find_the_answer);

        std::cout << "Doing other things while waiting for the answer..." << std::endl;

        // Wait for the result and retrieve it
        int answer = future.get(); // Blocks until the result is ready

        std::cout << "The answer is: " << answer << std::endl;



        #include <main.hpp>



#define PROMPT "sql>"

class PageRequestHandler : public HTTPRequestHandler
/// Return a HTML document with some JavaScript creating
/// a WebSocket connection.
{
public:
    void handleRequest(HTTPServerRequest &request, HTTPServerResponse &response)
    {
        response.setChunkedTransferEncoding(true);
        response.sendFile("WebNotifier.html", "text/html");
    }
};

/////////////////
//  WebSocket  //
/////////////////

class WebSocketRequestHandler : public HTTPRequestHandler
/// Handler for the WebSocket connection.
{
public:
    WebSocketRequestHandler() : _pWS(nullptr), _flags(0)
    {
    }

    ~WebSocketRequestHandler()
    {
        shutdown();
    }

    void shutdown()
    {
        if (_pWS)
        {
            _pWS->shutdown();
            delete _pWS;
        }
    }

    void send(const std::string &buffer)
    /// Pushes data to web client.
    {
        std::cout << "Sending data: " << buffer << std::endl;
        _pWS->sendFrame(buffer.data(), (int)buffer.size(), _flags);
    }

    void handleRequest(HTTPServerRequest &request, HTTPServerResponse &response)
    /// Creates WebSocket and accepts the connection request from web client.
    {
        try
        {
            if (!_pWS)
            {
                _pWS = new WebSocket(request, response);
                Timespan ts(600, 0);
                _pWS->setReceiveTimeout(ts);
                _pWS->setSendTimeout(ts);
            }
            std::cout << std::endl
                      << "WebSocket connection established." << std::endl
                      << PROMPT;

            char buffer[1024];
            int n;
            do
            {
                n = _pWS->receiveFrame(buffer, sizeof(buffer), _flags);
            } while (n > 0 || (_flags & WebSocket::FRAME_OP_BITMASK) != WebSocket::FRAME_OP_CLOSE);
            std::cout << "WebSocket connection closed." << std::endl;
        }
        catch (WebSocketException &exc)
        {
            std::cout << exc.displayText() << std::endl;
            switch (exc.code())
            {
            case WebSocket::WS_ERR_HANDSHAKE_UNSUPPORTED_VERSION:
                response.set("Sec-WebSocket-Version", WebSocket::WEBSOCKET_VERSION);
                // fallthrough
            case WebSocket::WS_ERR_NO_HANDSHAKE:
            case WebSocket::WS_ERR_HANDSHAKE_NO_VERSION:
            case WebSocket::WS_ERR_HANDSHAKE_NO_KEY:
                response.setStatusAndReason(HTTPResponse::HTTP_BAD_REQUEST);
                response.setContentLength(0);
                response.send();
                break;
            }
        }
    }

public:
    WebSocket *_pWS;
    int _flags;
};

class RequestHandlerFactory : public HTTPRequestHandlerFactory
/// Web request handler factory.
{
public:
    RequestHandlerFactory() : _pHandler(nullptr)
    {
        
    }

    HTTPRequestHandler *createRequestHandler(const HTTPServerRequest &request)
    {
        std::string uri = request.getURI();
        if (uri == "/")
        {
            return new PageRequestHandler;
        }
        else if (uri == "/ws")
        {
            if (!_pHandler)
                _pHandler = new WebSocketRequestHandler;
            return _pHandler;
        }

        if (uri != "/favicon.ico")
            std::cout << "Unknown URI: " << uri << std::endl;

        return nullptr;
    }

    WebSocketRequestHandler &handler()
    {
        if (!_pHandler)
            throw NullPointerException("WebSocket not connected.");
        return *_pHandler;
    }

private:
    WebSocketRequestHandler *_pHandler;
};

////////////////
//  Database  //
////////////////

class CSVFormatter : public RowFormatter
/// Formatter, passed to DB statement.
{
public:
    std::string &formatValues(const ValueVec &vals, std::string &formattedValues)
    /// Formats the result into comma separated list of values.
    {
        std::ostringstream str;

        ValueVec::const_iterator it = vals.begin();
        ValueVec::const_iterator end = vals.end();
        for (; it != end;)
        {
            str << it->convert<std::string>();
            if (++it != end)
                str << ',';
            else
                break;
        }

        return formattedValues = str.str();
    }
};

class DBEventHandler
/// Handler for DB insert/update events.
{
public:
    DBEventHandler(RequestHandlerFactory &factory) : _session("SQLite", "sample.db"),
                                                     _factory(factory),
                                                     _notifier(_session)
    /// Constructor; opens/initializes the database and associates
    /// notification events with their respective handlers.
    {
        initDB();
        _notifier.insert += delegate(this, &DBEventHandler::onInsert);
        _notifier.update += delegate(this, &DBEventHandler::onUpdate);
    }

    ~DBEventHandler()
    /// Destructor; unregisters the notification events.
    {
        _notifier.insert -= delegate(this, &DBEventHandler::onInsert);
        _notifier.update -= delegate(this, &DBEventHandler::onUpdate);
    }

    std::size_t execute(const std::string &sql)
    /// Exectutes the SQL statement.
    {
        Statement stmt = (_session << sql);
        return stmt.execute();
    }

    Poco::Data::Session &session()
    {
        return _session;
    }

private:
    void initDB()
    {
        _session << "DROP TABLE IF EXISTS Person", now;
        _session << "CREATE TABLE Person (Name VARCHAR(30), Address VARCHAR, Age INTEGER(3))", now;
    }

    Notifier *notifier(const void *pSender)
    {
        return reinterpret_cast<Notifier *>(const_cast<void *>(pSender));
    }

    void notify(Poco::Int64 rowID)
    /// Executes the query and sends the data to the web client.
    {
        std::ostringstream os;
        CSVFormatter cf;
        Statement stmt = (_session << "SELECT rowid, Name, Address, Age FROM Person WHERE rowid = ?", use(rowID), format(cf), now);
        os << RecordSet(stmt);
        _factory.handler().send(os.str());
    }

    void onInsert(const void *pSender)
    /// Insert event handler; retrieves the data for the affected row
    /// and calls notify.
    {
        Notifier *pN = notifier(pSender);
        Poco::Int64 rowID = pN->getRow();
        std::cout << "Inserted row " << rowID << std::endl;
        notify(rowID);
    }

    void onUpdate(const void *pSender)
    /// Update event handler; retrieves the data for the affected row
    /// and calls notify.
    {
        Notifier *pN = notifier(pSender);
        Poco::Int64 rowID = pN->getRow();
        std::cout << "Updated row " << rowID << std::endl;
        notify(rowID);
    }

    Poco::Data::Session _session;
    RequestHandlerFactory &_factory;
    Notifier _notifier;
};

void doHelp()
/// Displays help.
{
    std::cout << "Poco Data/Net example - HTML Page notifications from DB events" << std::endl;
    std::cout << "" << std::endl;
    std::cout << "To observe the functionality, take following steps:" << std::endl;
    std::cout << "" << std::endl;
    std::cout << "1) Run a web browser and connect to http://localhost:9980 ." << std::endl;
    std::cout << "2) Wait until \"WebSocket connection established.\" is displayed." << std::endl;
    std::cout << "3) Issue SQL commands to see the web page updated, e.g.:" << std::endl;
    std::cout << "\tINSERT INTO Person VALUES('Homer Simpson', 'Springfield', 42);" << std::endl;
    std::cout << "\tINSERT INTO Person VALUES('bart Simpson', 'Springfield', 12);" << std::endl;
    std::cout << "\tUPDATE Person SET Age=38 WHERE Name='Homer Simpson';" << std::endl;
    std::cout << "\tUPDATE Person SET Name='Bart Simpson' WHERE Name='bart Simpson';" << std::endl;
    std::cout << "" << std::endl;
    std::cout << "To end the program, enter \"exit\"." << std::endl;
    std::cout << "" << std::endl;
    std::cout << "To view this help, enter \"help\" or \"?\"." << std::endl;
}

void doShell(DBEventHandler &dbEventHandler)
/// Displays the shell and dispatches commands.
{
    doHelp();

    while (true)
    {
        std::cout << PROMPT;
        char cmd[512] = {0};
        std::cin.getline(cmd, 512);
        if (strncmp(cmd, "exit", 4) == 0)
            break;
        try
        {
            if ((strncmp(cmd, "help", 4) == 0) || cmd[0] == '?')
                doHelp();
            if (strlen(cmd) > 0)
            {
                std::size_t rows = dbEventHandler.execute(cmd);
                std::cout << rows << " row" << ((rows != 1) ? "s" : "") << " affected." << std::endl;
            }
        }
        catch (Exception &ex)
        {
            std::cout << ex.displayText() << std::endl;
        }
    }
}

///////////
//  Main //
///////////
struct Person
{
    std::string name;
    std::string address;
    int age;
};

int main(int argc, char **argv)
{
   
    try
    {
        
        std::cout << "Build Date: " << __DATE__ << "\n";
        std::cout << "Build Time: " << __TIME__ << "\n";
        std::cout << "\n";

        std::cout << "Program Started: " << utilFuncs::getDateTimeLocal() << "\n";
        

        std::cout << "argc: " << argc << "\n";
        for (int i = 0; i < argc; i++)
        {
            std::cout << "argv[" << i << "]: " << argv[i] << "\n";
        }
        std::cout << "\n";
        Poco::Data::SQLite::Connector::registerConnector();

        // HTTPServer instance
        RequestHandlerFactory *pFactory = new RequestHandlerFactory;
        SocketAddress sockAddr(IPAddress(), 9980);
        ServerSocket svs(sockAddr);
        HTTPServer srv(pFactory, svs, new HTTPServerParams);

        // DB stuff
        DBEventHandler dbEventHandler(*pFactory);

        // Start the HTTPServer
        srv.start();

        // Run shell
        doShell(dbEventHandler);

        // Stop the HTTPServer
        srv.stop();

    }
    catch (const Poco::Exception &e)
    {
        std::cerr << "Error: " << e.displayText() << " " << utilFuncs::getDateTimeLocal() << "\n";
    }
    catch (const boost::exception &e)
    {
        std::cerr << "Error: " << boost::diagnostic_information(e) << utilFuncs::getDateTimeLocal() << "\n";
    }
    catch (const std::exception &e)
    {
        std::cerr << "Error: " << e.what() << " " << utilFuncs::getDateTimeLocal() << "\n";
    }

    std::cout << "Program Stopped: " << utilFuncs::getDateTimeLocal() << "\n";

   
    return 0;
}



#include <main.hpp>
#include "file.hpp"
// This file must be manually included when
// using basic_parser to implement a parser.
namespace json = boost::json;

json::value
parse_file(char const *filename)
{
    file f(filename, "r");
    json::stream_parser p;
    boost::system::error_code ec;
    do
    {
        char buf[4096];
        auto const nread = f.read(buf, sizeof(buf));
        p.write(buf, nread, ec);
    } while (!f.eof());
    if (ec)
        return nullptr;
    p.finish(ec);
    if (ec)
        return nullptr;
    return p.release();
}

void pretty_print(std::ostream &os, json::value const &jv, std::string *indent = nullptr)
{
    std::string indent_;
    if (!indent)
        indent = &indent_;
    switch (jv.kind())
    {
    case json::kind::object:
    {
        os << "{\n";
        indent->append(4, ' ');
        auto const &obj = jv.get_object();
        if (!obj.empty())
        {
            auto it = obj.begin();
            for (;;)
            {
                os << *indent << json::serialize(it->key()) << " : ";
                pretty_print(os, it->value(), indent);
                if (++it == obj.end())
                    break;
                os << ",\n";
            }
        }
        os << "\n";
        indent->resize(indent->size() - 4);
        os << *indent << "}";
        break;
    }

    case json::kind::array:
    {
        os << "[\n";
        indent->append(4, ' ');
        auto const &arr = jv.get_array();
        if (!arr.empty())
        {
            auto it = arr.begin();
            for (;;)
            {
                os << *indent;
                pretty_print(os, *it, indent);
                if (++it == arr.end())
                    break;
                os << ",\n";
            }
        }
        os << "\n";
        indent->resize(indent->size() - 4);
        os << *indent << "]";
        break;
    }

    case json::kind::string:
    {
        os << json::serialize(jv.get_string());
        break;
    }

    case json::kind::uint64:
    case json::kind::int64:
    case json::kind::double_:
        os << jv;
        break;

    case json::kind::bool_:
        if (jv.get_bool())
            os << "true";
        else
            os << "false";
        break;

    case json::kind::null:
        os << "null";
        break;
    }

    if (indent->empty())
        os << "\n";
}

int main(int argc, char **argv)
{
    try
    {
        
        std::cout << "Build Date: " << __DATE__ << ENDLINE;
        std::cout << "Build Time: " << __TIME__ << ENDLINE;
        std::cout << ENDLINE;
      
        std::cout << "Program Started: " << myUtilFuncs::getDateTimeLocal() << ENDLINE;

        std::cout << "argc: " << argc << ENDLINE;
        for (int i = 0; i < argc; i++)
        {
            std::cout << "argv[" << i << "]: " << argv[i] << ENDLINE;
        }

        std::cout << ENDLINE;


        std::filesystem::path temp = std::filesystem::temp_directory_path();
        string filePath = temp.string() + "/" + "gggg.json";
        auto const jv = parse_file(filePath.c_str());
        pretty_print(std::cout, jv);
    }
    catch (const Poco::Exception &e)
    {
        std::cerr << "Error: " << e.displayText() << " " << myUtilFuncs::getDateTimeLocal() << ENDLINE;
    }
    catch (const boost::exception &e)
    {
        std::cerr << "Error: " << boost::diagnostic_information(e) << myUtilFuncs::getDateTimeLocal() << ENDLINE;
    }
    catch (const std::exception &e)
    {
        std::cerr << "Error: " << e.what() << " " << myUtilFuncs::getDateTimeLocal() << ENDLINE;
    }

    std::cout << "Program Stopped: " << myUtilFuncs::getDateTimeLocal() << ENDLINE;

    return 0;
}


using boost::asio::ip::tcp;

int main(int argc, char **argv)
{
    try
    {
        std::cout << "Build Date: " << __DATE__ << ENDLINE;
        std::cout << "Build Time: " << __TIME__ << ENDLINE;
        std::cout << ENDLINE;
      
        std::cout << "Program Started: " << myUtilFuncs::getDateTimeLocal() << ENDLINE;

        std::cout << "argc: " << argc << ENDLINE;
        for (int i = 0; i < argc; i++)
        {
            std::cout << "argv[" << i << "]: " << argv[i] << ENDLINE;
        }
        boost::asio::io_context io_context;

        tcp::acceptor acceptor(io_context, tcp::endpoint(tcp::v4(), 13));

        for (;;)
        {
            tcp::socket socket(io_context);
            acceptor.accept(socket);
            std::cout << "Client Connected: " << myUtilFuncs::getDateTimeLocal() << ENDLINE;

            std::string message = myUtilFuncs::getDateTimeLocal();

            boost::system::error_code ignored_error;
            boost::asio::write(socket, boost::asio::buffer(message), ignored_error);

        }

        std::cout  << ENDLINE;
    }
    catch (const Poco::Exception &e)
    {
        std::cerr << "Error: " << e.displayText() << " " << myUtilFuncs::getDateTimeLocal() << ENDLINE;
    }
    catch (const boost::exception &e)
    {
        std::cerr << "Error: " << boost::diagnostic_information(e) << myUtilFuncs::getDateTimeLocal() << ENDLINE;
    }
    catch (const std::exception &e)
    {
        std::cerr << "Error: " << e.what() << " " << myUtilFuncs::getDateTimeLocal() << ENDLINE;
    }

    std::cout << "Program Stopped: " << myUtilFuncs::getDateTimeLocal() << ENDLINE;

    return 0;
}

#include <fmt/core.h>
fmt::print("Hello, {}!{}", "world" , ENDLINE);
fmt::print("The answer is {{{}}}.{}", 42, ENDLINE);